<!DOCTYPE HTML>
<html lang="en">
    <head>
        <!--
        The MIT License
        
        Copyright (c) 2010-2012 danx0r (Daniel B. Miller), Authors of three.js. 
        All rights reserved.
        
        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:
        
        The above copyright notice and this permission notice shall be included in
        all copies or substantial portions of the Software.
        
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        THE SOFTWARE.
        -->
        <title>BUSY BOXES</title>
        <meta charset="utf-8">
        <style type="text/css">
            body {
                font-family: Monospace;
                font-size: 12px;
                background-color: #f0f0f0;
                margin: 0px;
                overflow: hidden;
            }
        </style>
    </head>
    <body>
        <div style="position:absolute;font-size:large">
            Generation:
            <span id="generation"></span>
            <br/>
            phase:
            <span id="showphase"></span>
            <br/>
            Direction:
            <span id="direction"></span>
            <br/>
            Duplicate:
            <span id="duplicates"></span>
            <br/>
            <!--
            Hash:
            <span id="showhash" style="font-size:small;"></span>
            <br/>
            -->
            Cells:
            <span id="cellcount"></span>
            <br/>
            Cursor:
            <span id="cursorpos"></span>
            <br/>
            <br/>
            <a href="?00#A/Qbefl0">Glider 1</a>
            <br/>
            <a href="?01#A/Qbhilbhibbdal0">Glider 2</a>
            <br/>
            <a href="?02#A/QSeZhlSeblqb0">Glider 3</a>
            <br/>
            <a href="?03#A/SeZhlSeZhbaek0">Glider 4</a>
            <br/>
            <a href="?04#A/djclfhhhbXihldihb0">Glider 5</a>
            <br/>
            <a href="?05#A/ecdlahfdehlchd0">Glider 6</a>
            <br/>
            <a href="?06#A/biflXifbeeei0">Cycle 1</a> (12)
            <br/>
            <a href="?07#A/Qbefldhib0">Cycle 2</a> (24)
            <br/>
            <a href="?08#A/QTflYi0">Cycle 3</a> (24)
            <br/>
            <a href="?09#A/aeeefhechhZhlWei0">Cycle 4</a> (42)
            <br/>
            <a href="?10#A/efifdfelahfZfb0">Cycle 5</a> (48)
            <br/>
            <a href="?11#A/biflXifbefehafh0">Cycle 6</a> (60)
            <br/>
            <a href="?12#A/QbiflXifbWfhTjlaea">Cycle 7</a> (108)
            <br/>
            <a href="?13#A/feehlTfbXhilbifbbeflThb0">Cycle 8</a> (144)
            <br/>
            <a href="?14#A/affZhlafhXhebafhfjfhl0">Cycle 9</a> (582)
            <br/>
            <a href="?15#A/ZflTfbZhlVhbZflahhZfbYieiffThl0">Cycle 10</a> (3966)
            <br/>
            <a href="?1x#A/fhielfhfhbXehl0">Boomerang</a> (60)
            <br/>
            <a href="?16#A/Tflebhkbhib0">Deflect (Routing)</a>
            <br/>
            <a href="?17#A/ablbfelfriWbbhil0">Logic (Interaction Gate)</a>
            <br/>
            <a href="?18#A/ablbfelflicb">Move</a>
            <br/>
            <a href="?19#A/bdelbhibbhilbhibfZhjlbefb0">Fast and Slow</a>
            <br/>
            <a href="?20#A/ThlZfbfXhZlbhebfofolbhib0">Capture and emit</a>
            <br/>
            <a href="?21#A/XihlfiefbVhlZfbbhilaeeThbahhXfelWhhffffb0">Delayed release</a>
            <br/>
            <a href="?22#A/fcfilTfbTflTfbVhlVhbVhlXehbVhlVhbXehlVhbVhlXehbVhlVhbekdffXfnlbefb0">Attraction</a>
            <br/>
            <a href="?23#A/fiZilfamfbfddVlbjebbi1lfbfPbfjfdlfhuibecdpfdfplelhWffambfshYlfTjlbebhmfpjjlfqZUbfWnWlfjRtbfcqdlfkkfbfdcqlfhiYbfaijlfnYmbfesVlfiVmbfZicl0">Order Out of Chaos</a>
            <br/>
            <a href="?24#A/fcfilTfbTflTfbVhlVhbVhlXehbUiXehlUiXehbVhlVhbejeffeUXlfopebfXiolVhbVhlVhbVhlThbThlThbThlXefbfndVl0">Structure And Decay</a>
            <br/>
            <a href="?25#A/eeddfjljlbfebVflfidkbfcfcldjibfcfilXkdbfidildehbbijldjibfffdlfheibdejlVbbfdkeldhcbfhlfldefbfhdjlfjicbfhdllbebbfikhlfbckbbkflddibdhelfflfbfjcelThbfdkilfhcebfjhhlbefbfiijlfcebbTjlfkehbfbielfjjhbfdfdlfihibXcjlbhebbefldifbVllficfbdcjlffdhbfkhilfcihbfhhdlfjcibXhelddibfjdhlfhiebVdlfdkibfifilfcebbfhhllfhfbbfhhllfijcbfdeilfifibdcflbkbbTllXidbbfelffikbfecdlXfibbkdlfclibfkfilfhhfbTdlbclbfjdblfeihbfjcilZdbXidlffikbfhddlXkfbdjclbelbfijelXfibXidlddeb">
                Big Bang (Entropy)</a>
            <br/>
            <a href="faq.html" target="_blank">faq</a>
        </div>
        <div style="display:none">
            <div id="banner">
                <p>
                <span style="background-color: #fff; opacity:0.5; border-bottom: 1px solid #ddd; padding: 8px 10px; font-size:medium">
                    <b>click & drag to rotate view | arrows move cursor; U & D for up/down | ENTER to create/delete | S to step</b>
                </span>
                <div style="opacity:0.7">
                    </p><button onclick="toggleRunning()">RUN/STOP</button>
                    <button onclick="fastSlow()">FAST/SLOW</button>
                    <button onclick="window.location.reload(true)">RESET</button>
                    <button onclick="reverseDirection()">DIRECTION</button>
                    <button onclick="clearScreen()">CLEAR</button>
                    <button onclick="randomCells(12, -2, 1)">RANDOM</button>
                </div>
                </p>
            </div>
        </div>
        <script type="text/javascript" src="js/ThreeCanvas.js"></script>
        <script type="text/javascript" src="js/Cube.js"></script>
        <script type="text/javascript" src="js/Plane.js"></script>
        <script type="text/javascript">
            var DEBUG = false;
            var offs1 = [+2, +1, -1, -2, +2, +1, -1, -2];
            var offs2 = [+1, +2, +2, +1, -1, -2, -2, -1];
            var move1 = [+1, -1, +1, -1, +1, -1, +1, -1];
            var move2 = [-1, +1, +1, -1, +1, -1, -1, +1];
            var cursor = [0, 0, 0];
            var grid = {};
            var isRunning = false;
            var direction = "forward";
            var hashmap = {};
            var lasthash = "";
            var frame = 0;
            var cellCount = 0;
            var mode = "mirror";
            var axisMin = -12;
            var axisMax = 11;
            var processSpeed = "slow";
            var container, interval,
            camera, scene, renderer,
            projector, plane, cube, linesMaterial,
            color = 0,colors = [ 0xDF1F1F, 0xDFAF1F, 0x80DF1F, 0x1FDF50, 0x1FDFDF, 0x1F4FDF, 0x7F1FDF, 0xDF1FAF, 0xEFEFEF, 0x303030 ],
            ray, brush, objectHovered,
            mouse3D, isMouseDown = false, onMouseDownPosition,
            radious = 2000, theta = 0, onMouseDownTheta = 45, phi = 60, onMouseDownPhi = 60;
            init();
            render();

            function init() {
                if(DEBUG) console.log("init start")
                container = document.createElement( 'div' );
                document.body.appendChild( container );

                var info = document.createElement( 'div' );
                info.style.position = 'absolute';
                info.style.top = '5px';
                info.style.width = '100%';
                info.style.textAlign = 'center';
                info.innerHTML = document.getElementById("banner").innerHTML;
                container.appendChild( info );
 
                camera = new THREE.Camera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
                if(DEBUG) console.log("camera:", camera);
                camera.position.x = radious * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
                camera.position.z = radious * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
//                camera.position.y = 200;

                scene = new THREE.Scene();

                // Grid

                var geometry = new THREE.Geometry();
                geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( axisMin * 50, 0, 0 ) ) );
                geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( (axisMax+1) * 50, 0, 0 ) ) );

                linesMaterial = new THREE.LineColorMaterial( 0x000000, 0.2 );

                for ( var i = 0; i <= axisMax - axisMin + 1; i ++ ) {

                    var line = new THREE.Line( geometry, linesMaterial );
                    line.position.z = ( i * 50 ) + axisMin * 50;
                    scene.addObject( line );

                    var line = new THREE.Line( geometry, linesMaterial );
                    line.position.x = ( i * 50 ) + axisMin * 50;
                    line.rotation.y = 90 * Math.PI / 180;
                    scene.addObject( line );

                }

                projector = new THREE.Projector();

                plane = new THREE.Mesh( new Plane( 1000, 1000 ) );
                plane.rotation.x = - 90 * Math.PI / 180;
                scene.addObject( plane );

                cube = new Cube( 50, 50, 50 );

                ray = new THREE.Ray( camera.position, null );

                brush = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ color ], 0.4 ) );
                //brush.position.y = brushY;
                setObjPosition(brush, cursor);
                brush.overdraw = true;
                scene.addObject( brush );

                onMouseDownPosition = new THREE.Vector2();

                // Lights

                var ambientLight = new THREE.AmbientLight( 0x404040 );
                scene.addLight( ambientLight );

                var directionalLight = new THREE.DirectionalLight( 0xffffff );
                directionalLight.position.x = 1;
                directionalLight.position.y = 1;
                directionalLight.position.z = 0.75;
                directionalLight.position.normalize();
                scene.addLight( directionalLight );

                var directionalLight = new THREE.DirectionalLight( 0x808080 );
                directionalLight.position.x = - 1;
                directionalLight.position.y = 1;
                directionalLight.position.z = - 0.75;
                directionalLight.position.normalize();
                scene.addLight( directionalLight );

                renderer = new THREE.CanvasRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );

                container.appendChild(renderer.domElement);

                document.addEventListener( 'keydown', onDocumentKeyDown, false );

                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                document.addEventListener( 'mousedown', onDocumentMouseDown, false );
                document.addEventListener( 'mouseup', onDocumentMouseUp, false );

                document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );

                if ( window.location.hash ) {

                    buildFromHash();
                }

                setInterval(mainLoopFast, 14);
                setInterval(mainLoopSlow, 140);
                render();
            }
            
            function mainLoopFast() {
                if (processSpeed == "fast") {
                    mainLoop();
                }
            }
            
            function mainLoopSlow() {
                if (processSpeed == "slow") {
                    mainLoop();
                }
            }
            
            function mainLoop() {
                document.getElementById("generation").innerHTML = frame;
                document.getElementById("showphase").innerHTML = (frame % 6 + 6) %6;
                document.getElementById("direction").innerHTML = direction;
                if (isRunning) {
                    updateHash(true);
                    if (direction == "reverse") {
                        frame--;
                    }
                    if(DEBUG) console.log("frame:", frame)
                    var cells = [];
                    for(key in grid) {
                        cells.push([key, grid[key]]);
                    }
                    if(DEBUG) console.log("cells:", cells)
                    var moves = []
                    for (var i in cells) {
                        cell = cells[i];
                        if(DEBUG) console.log(cell[0], cell[1]);
                        xyz = eval('[' + cell[0] + ']');
                        
                        if (((xyz[0] + xyz[1] + xyz[2]) & 1) == (frame & 1)) {                  // only operate on cells appropriate for this phase
                            if(DEBUG) console.log("DEBUG cell:", xyz, "-----------------------------------");
                            var x1, x2                                          // our two axes for today
                            switch( (frame % 3 + 3) %3 ) {                      // ach, Javascript you old goat
                                case 0: x1=0; x2=1; break;
                                case 1: x1=1; x2=2; break;
                                case 2: x1=2; x2=0; break;
                            }
                            var move = getMove(xyz, x1, x2);
                            if (move) {
                                var mvto = [xyz[0] + move[0], xyz[1] + move[1], xyz[2] + move[2]];
                                if(!getGrid(mvto)) {
                                    var mv = getMove(mvto, x1, x2);                             // tricky -- read the paper. Can only move if the location we move to would have moved to us (swap)
                                    if (mv && mv[0] + move[0] == 0 && mv[1] + move[1] == 0 && mv[2] + move[2] == 0) {
                                        if(DEBUG) console.log("  mvto:", mvto);
                                        moves.push([xyz, cell[1], mvto]);
                                    }
                                }
                            }
                        }
                    }
                    for (i in moves) {
                        var args = moves[i];
                        moveCell(args[0], args[1], args[2]);
                    }
                    render();
                    if (direction == "forward") {
                        frame++;
                    }
                 }
            }
            
            function getMove(xyz, x1, x2) {
                if(x1 == null) x1 = 0;
                if(x2 == null) x2 = 2;
                var move = null;
                var d = [0, 0, 0]
                for (i = 0; i < 8; i++) {
                    d[x1] = offs1[i];
                    d[x2] = offs2[i];
                    if (getGrid([xyz[0] + d[0], xyz[1] + d[1], xyz[2] + d[2]])) {
                        var mv = [0, 0, 0];
                        mv[x1] = move1[i];
                        mv[x2] = move2[i];
                                                                            if (DEBUG) console.log("  mv:", mv);
                        if (move == null) {
                            move = mv;
                                                                            if (DEBUG) console.log("  move:", move);
                        }
                        else {
                            if (!v3eq(move, mv)) {
                                move = false;                               // conflicting moves -- give up
                                                                            if (DEBUG) console.log("  move:", move);
                                break;
                            }
                        }
                    }
                }
                if (move && mode == "mirror") {
                    for (var axis = 0; axis < 3; axis++) {
                        if (xyz[axis] + move[axis] > axisMax) {
                            move = false;
                            break;
                        }
                        if (xyz[axis] + move[axis] < axisMin) {
                            move = false;
                            break;
                        }
                    }
                }
                return move
            }
            
            function v3eq(v1, v2){
                return (v1[0] == v2[0] && v1[1] == v2[1] && v1[2] == v2[2]);
            }

            function moveCell(oldxyz, mesh, newxyz) {
                setObjPosition(mesh, newxyz);
                delGrid(oldxyz);
                putGrid(mesh, newxyz);
            }

            // convert grid coord to 3D coord and set obj.position accordingly given vector [x,y,z]
            function setObjPosition(obj, xyz) {
                obj.position.x = xyz[0] * 50 + 25;
                obj.position.y = xyz[1] * 50 + 25;
                obj.position.z = xyz[2] * 50 + 25;
            }
            
            function setBrushPosition(xyz) {
                setObjPosition(brush, xyz);
                if ((xyz[0] + xyz[1] + xyz[2]) % 2 == 0) {
                    setBrushColor(0);                    
                }
                else {
                    setBrushColor(5);                    
                }
                document.getElementById("cursorpos").innerHTML = xyz[0] + "," + xyz[1] + "," + xyz[2]
            }

            function putGrid(obj, xyz) {
                grid[xyz] = obj;
            }

            function getGrid(xyz) {
                return grid[xyz];
            }

            function delGrid(xyz) {
                delete grid[xyz];
            }
            
            function toggleRunning(){
                if (isRunning) {
                    cursor = [0, 0, 0];
                    isRunning = false;
                }
                else {
                    cursor = [0, 2000, 0];
                    isRunning = true;
                }
                setBrushPosition(cursor);
            }
            
            function clampCursor() {
                for (var x=0; x<3; x++) {
                    if (cursor[x] < axisMin) cursor[x] = axisMin;
                    if (cursor[x] > axisMax) cursor[x] = axisMax;
                }
            }

            function reverseDirection(){
                hashmap = {}
                document.getElementById("duplicates").innerHTML = "";
                if (direction == "forward") {
                    direction = "reverse";
                }
                else {
                    direction = "forward";
                }
                updateHash(true);
            }

            function onDocumentKeyDown( event ) {

if(DEBUG) console.log("key:", event.keyCode);
                switch( event.keyCode ) {
                    case 37: 
                        cursor[0]--;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 38: 
                        cursor[2]--;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 39: 
                        cursor[0]++;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 40: 
                        cursor[2]++;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 85: 
                        cursor[1]++;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 68: 
                        cursor[1]--;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 83:
                        isRunning = true;
                        mainLoop();
                        isRunning = false;
                        break;
                    case 32:
                        toggleRunning();
                        break;
                    case 70:
                        processSpeed = "fast";
                        if (!isRunning) {
                            toggleRunning();
                        }
                        break;
                    case 10:
                    case 13:
                        var obj = getGrid(cursor);
                        if (obj) {
                            scene.removeObject(obj);
                            delGrid(cursor);
                        }
                        else {
                            var voxel = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ color ] ) );
                            putGrid(voxel, cursor);
                            setObjPosition(voxel, cursor);
                            voxel.overdraw = true;
                            scene.addObject( voxel );
                        }
                        updateHash();
                        render(); 
var temp = [];
for(var e in grid) temp.push(e);
if(DEBUG) console.log("grid:", temp)
                        break;
                }

            }

            function onDocumentMouseDown( event ) {

                event.preventDefault();

                isMouseDown = true;

                onMouseDownTheta = theta;
                onMouseDownPhi = phi;
                onMouseDownPosition.x = event.clientX;
                onMouseDownPosition.y = event.clientY;

            }

            function onDocumentMouseMove( event ) {

                var dx = event.clientX - onMouseDownPosition.x;
                var dy = event.clientY - onMouseDownPosition.y;
//if(DEBUG) console.log("dx, dy:", dx, dy)
                event.preventDefault();

                if ( isMouseDown ) {

                    theta = - ( ( event.clientX - onMouseDownPosition.x ) * 0.5 ) + onMouseDownTheta;
                    phi = ( ( event.clientY - onMouseDownPosition.y ) * 0.5 ) + onMouseDownPhi;

                    phi = Math.min( 180, Math.max( 0, phi ) );

                    camera.position.x = radious * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                    camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
                    camera.position.z = radious * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                    if(DEBUG) console.log("camera:", camera.position)
                    camera.updateMatrix();

                }

                mouse3D = projector.unprojectVector( new THREE.Vector3( ( event.clientX / renderer.domElement.width ) * 2 - 1, - ( event.clientY / renderer.domElement.height ) * 2 + 1, 0.5 ), camera );
                ray.direction = mouse3D.subSelf( camera.position ).normalize();

                render();

            }

            function onDocumentMouseUp( event ) {

                event.preventDefault();

                isMouseDown = false;

                onMouseDownPosition.x = event.clientX - onMouseDownPosition.x;
                onMouseDownPosition.y = event.clientY - onMouseDownPosition.y;

            }

            function onDocumentMouseWheel( event ) {

                radious -= event.wheelDeltaY;

                camera.position.x = radious * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
                camera.position.z = radious * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                camera.updateMatrix();

                render();

            }

            function setBrushColor( value ) {
                color = value;
                brush.material[ 0 ].color.setHex( colors[ color ] ^ 0x4C000000 );

                render();

            }

            function buildFromHash() {
                var hash = window.location.hash;
                var phase = hash.substr(hash.length-1, hash.length);
                frame = parseInt(phase);
                if ('' + frame == "NaN") {
                    frame = 0;
                }
                else {
                    hash = hash.substr( 0, hash.length - 1 );
                }
                hash = hash.substr( 1 );
                version = hash.substr( 0, 2 );

                if ( version == "A/" ) {

                    var current = { x: 0, y: 0, z: 0, c: 0 }
                    var data = decode( hash.substr( 2 ) );
                    var i = 0, l = data.length;

                    while ( i < l ) {

                        var code = data[ i ++ ].toString( 2 );

                        if ( code.charAt( 1 ) == "1" ) current.x += data[ i ++ ] - 32;
                        if ( code.charAt( 2 ) == "1" ) current.y += data[ i ++ ] - 32;
                        if ( code.charAt( 3 ) == "1" ) current.z += data[ i ++ ] - 32;
                        if ( code.charAt( 4 ) == "1" ) current.c += data[ i ++ ] - 32;
                        if ( code.charAt( 0 ) == "1" ) {
                            var voxel = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ current.c ] ) );
                            voxel.position.x = current.x * 50 + 25;
                            voxel.position.y = current.y * 50 + 25;
                            voxel.position.z = current.z * 50 + 25;
                            voxel.overdraw = true;
                            scene.addObject( voxel );
                            putGrid(voxel, [current.x, current.y, current.z])
                        }
                    }

                } else {

                    var data = decode( hash );

                    for ( var i = 0; i < data.length; i += 4 ) {

                        var voxel = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ data[ i + 3 ] ] ) );
                        voxel.position.x = ( data[ i ] - 20 ) * 25;
                        voxel.position.y = ( data[ i + 1 ] + 1 ) * 25;
                        voxel.position.z = ( data[ i + 2 ] - 20 ) * 25;
                        voxel.overdraw = true;
                        scene.addObject( voxel );

                    }

                }
                updateHash();

            }

            function updateHash(noLink) {

                var data = [],
                current = { x: 0, y: 0, z: 0, c: 0 },
                last = { x: 0, y: 0, z: 0, c: 0 },
                code;
                cellCount = 0;

                for ( var i in scene.objects ) {

                    object = scene.objects[ i ];

                    if ( object instanceof THREE.Mesh && object !== plane && object !== brush ) {
                        cellCount++;
                        current.x = ( object.position.x - 25 ) / 50;
                        current.y = ( object.position.y - 25 ) / 50;
                        current.z = ( object.position.z - 25 ) / 50;
                        current.c = colors.indexOf( object.material[ 0 ].color.hex & 0xffffff );

                        code = 0;

                        if ( current.x != last.x ) code += 1000;
                        if ( current.y != last.y ) code += 100;
                        if ( current.z != last.z ) code += 10;
                        if ( current.c != last.c ) code += 1;

                        code += 10000;

                        data.push( parseInt( code, 2 ) );

                        if ( current.x != last.x ) {

                            data.push( current.x - last.x + 32 );
                            last.x = current.x;

                        }

                        if ( current.y != last.y ) {

                            data.push( current.y - last.y + 32 );
                            last.y = current.y;

                        }

                        if ( current.z != last.z ) {

                            data.push( current.z - last.z + 32 );
                            last.z = current.z;

                        }

                        if ( current.c != last.c ) {

                            data.push( current.c - last.c + 32 );
                            last.c = current.c;

                        }

                    }

                }

                data = encode( data );
                data +=     (frame % 6 + 6) %6
                if (!noLink) {
                    window.location.hash = "A/" + data;
//                    document.getElementById('link').href = "http://mrdoob.com/projects/voxels/#A/" + data;
                }
                //document.getElementById('showhash').innerHTML = data;
                if (data != lasthash) {
                    if (data in hashmap) {
                        document.getElementById("duplicates").innerHTML = frame + "=" + hashmap[data] + " cycle: " + Math.abs(frame - hashmap[data]);
                    }
                }
                document.getElementById('cellcount').innerHTML = cellCount;
                hashmap[data] = frame;
                lasthash = data;
            }

            function render() {

                renderer.render( scene, camera );

            }

            function save() {

                linesMaterial.color.setRGBA( 0, 0, 0, 0 );
                //brush.position.y = brushY;
                setObjPosition(brush, cursor);
                render();

                window.open( renderer.domElement.toDataURL('image/png'), 'mywindow' );

                linesMaterial.color.setRGBA( 0, 0, 0, 0.2 );
                render();

            }

            function clearScreen(noReload) {
                grid = {};
                if (!noReload) {
                    if (!confirm('Are you sure?')) {
                        return
                    }
                }

                window.location.hash = "";

                var i = 0;

                while ( i < scene.objects.length ) {

                    object = scene.objects[ i ];

                    if ( object instanceof THREE.Mesh && object !== plane && object !== brush ) {

                        scene.removeObject( object );
                        continue;
                    }

                    i ++;
                }

                frame = 0;
                updateHash();
                if (!noReload) {
                    window.location.reload(true);
                }
            }

            function randomCells(){
                var val = prompt("specify width, count:", "5, 20");
                if (!val) {
                    alert ("oops! nothing");
                } 
                var i = val.indexOf(",");
                if (i < 0) {
                    alert("missing comma!");
                    return;
                }
                var width, count;
                width = parseFloat(val.substr(0,i));
                count = parseInt(val.substr(i+1));
                var axMax, axMin;
                if (width != parseInt(width)) {
                    var tot = axisMax - axisMin;
                    width = parseInt(tot * width);
                    axMax = [axisMax, axisMax, axisMax];
                    axMin = [tot - width + axisMin, axisMin, axisMin];
                }
                else {
                    width = parseInt(width);
                    axMax = parseInt(width - .5) >> 1;
                    axMin = axMax - (width - 1);
                    axMax = [axMax, axMax, axMax];
                    axMin = [axMin, axMin, axMin];
                }
                clearScreen(true);
                for (i = 0; i < count; i++) {
                    var phase = -1;
                    while ( (cursor in grid) || (phase != (i & 1)) ) {
                        for (var axis = 0; axis < 3; axis++) {
                            cursor[axis] = Math.floor(Math.random() * (axMax[axis] - axMin[axis] + 1) + axMin[axis]);
                        }
                        phase = (cursor[0] + cursor[1] + cursor[2]) & 1;
                    }
                    setBrushPosition(cursor);
                    var voxel = new THREE.Mesh(cube, new THREE.MeshColorFillMaterial(colors[color]));
                    putGrid(voxel, cursor);
                    setObjPosition(voxel, cursor);
                    voxel.overdraw = true;
                    scene.addObject(voxel);
                }

                updateHash();
                window.location.reload(true);
            }

            // https://gist.github.com/665235

            function decode( string ) {

                var output = [];
                string.split('').forEach( function ( v ) { output.push( "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf( v ) ); } );
                return output;

            }

            function encode( array ) {

                var output = "";
                array.forEach( function ( v ) { output += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt( v ); } );
                return output;

            }

            function fastSlow() {
                if (processSpeed == "fast") {
                    processSpeed = "slow";
                }
                else {
                    processSpeed = "fast";
                }
            }
        </script>
    </body>
</html>
