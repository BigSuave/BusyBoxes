<!DOCTYPE HTML>
<html lang="en">
    <head>
        <title>Voxels</title>
        <meta charset="utf-8">
        <style type="text/css">
            body {
                font-family: Monospace;
                font-size: 12px;
                background-color: #f0f0f0;
                margin: 0px;
                overflow: hidden;
            }
        </style>
    </head>
    <body>
        <script type="text/javascript" src="js/ThreeCanvas.js"></script>
        <script type="text/javascript" src="js/Cube.js"></script>
        <script type="text/javascript" src="js/Plane.js"></script>

        <script type="text/javascript"> 
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-86951-7']);
          _gaq.push(['_trackPageview']);
 
          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ga);
          })();
        </script>

        <script type="text/javascript">
            var offs1 = [+2, +1, -1, -2, +2, +1, -1, -2];
            var offs2 = [+1, +2, +2, +1, -1, -2, -2, -1];
            var move1 = [+1, -1, +1, -1, +1, -1, +1, -1];
            var move2 = [-1, +1, +1, -1, +1, -1, -1, +1];
            var cursor = [0, 0, 0];
            var grid = {};
            var isRunning = false;
            var frame = 0;
            var container, interval,
            camera, scene, renderer,
            projector, plane, cube, linesMaterial,
            color = 0,colors = [ 0xDF1F1F, 0xDFAF1F, 0x80DF1F, 0x1FDF50, 0x1FDFDF, 0x1F4FDF, 0x7F1FDF, 0xDF1FAF, 0xEFEFEF, 0x303030 ],
            ray, brush, objectHovered,
            mouse3D, isMouseDown = false, onMouseDownPosition,
            radious = 1600, theta = 45, onMouseDownTheta = 45, phi = 60, onMouseDownPhi = 60,
            isShiftDown = false;

            init();
            render();

            function init() {

                container = document.createElement( 'div' );
                document.body.appendChild( container );

                var info = document.createElement( 'div' );
                info.style.position = 'absolute';
                info.style.top = '5px';
                info.style.width = '100%';
                info.style.textAlign = 'center';
                info.innerHTML = '<span style="color: #444; background-color: #fff; border-bottom: 1px solid #ddd; padding: 8px 10px;">' +
                '<strong> click</strong>: add cell, <strong>shift + click</strong>:' +
                'remove voxel, <strong>drag</strong>: rotate | <a id="link" href="" target="_blank">share</a> <a href="javascript:save();">save</a> <a href="javascript:clear();">clear</a></span>';
                container.appendChild( info );
 
                camera = new THREE.Camera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
                console.log("camera:", camera);
                camera.position.x = radious * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
                camera.position.z = radious * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                camera.position.y = 200;

                scene = new THREE.Scene();

                // Grid

                var geometry = new THREE.Geometry();
                geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( - 500, 0, 0 ) ) );
                geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( 500, 0, 0 ) ) );

                linesMaterial = new THREE.LineColorMaterial( 0x000000, 0.2 );

                for ( var i = 0; i <= 20; i ++ ) {

                    var line = new THREE.Line( geometry, linesMaterial );
                    line.position.z = ( i * 50 ) - 500;
                    scene.addObject( line );

                    var line = new THREE.Line( geometry, linesMaterial );
                    line.position.x = ( i * 50 ) - 500;
                    line.rotation.y = 90 * Math.PI / 180;
                    scene.addObject( line );

                }

                projector = new THREE.Projector();

                plane = new THREE.Mesh( new Plane( 1000, 1000 ) );
                plane.rotation.x = - 90 * Math.PI / 180;
                scene.addObject( plane );

                cube = new Cube( 50, 50, 50 );

                ray = new THREE.Ray( camera.position, null );

                brush = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ color ], 0.4 ) );
                //brush.position.y = brushY;
                setObjPosition(brush, cursor);
                brush.overdraw = true;
                scene.addObject( brush );

                onMouseDownPosition = new THREE.Vector2();

                // Lights

                var ambientLight = new THREE.AmbientLight( 0x404040 );
                scene.addLight( ambientLight );

                var directionalLight = new THREE.DirectionalLight( 0xffffff );
                directionalLight.position.x = 1;
                directionalLight.position.y = 1;
                directionalLight.position.z = 0.75;
                directionalLight.position.normalize();
                scene.addLight( directionalLight );

                var directionalLight = new THREE.DirectionalLight( 0x808080 );
                directionalLight.position.x = - 1;
                directionalLight.position.y = 1;
                directionalLight.position.z = - 0.75;
                directionalLight.position.normalize();
                scene.addLight( directionalLight );

                renderer = new THREE.CanvasRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );

                container.appendChild(renderer.domElement);

                document.addEventListener( 'keydown', onDocumentKeyDown, false );
                document.addEventListener( 'keyup', onDocumentKeyUp, false );

                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                document.addEventListener( 'mousedown', onDocumentMouseDown, false );
                document.addEventListener( 'mouseup', onDocumentMouseUp, false );

                document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );

                if ( window.location.hash ) {

                    buildFromHash();

                }

                setInterval(mainLoop, 500);
            }
            
            function mainLoop() {
                if (isRunning) {
                    console.log("frame:", frame)
                    var cells = [];
                    for(key in grid) {
                        cells.push([key, grid[key]]);
                    }
                    console.log("cells:", cells)
                    for (var i in cells) {
                        cell = cells[i];
                        console.log(cell[0], cell[1]);
                        xyz = eval('[' + cell[0] + ']');
                        
                        // test moveCell
                        //nu = [xyz[0] + 1, xyz[1] + 1, xyz[2]];
                        //moveCell(xyz, cell[1], nu);
                        // here's the rub:
                        // initial test on y=0 only -- xz plane
                        // need to do this in every plane, for all 3 planes: xy, yz, xz
                        if (((xyz[0] + xyz[1] + xyz[2]) & 1) == (frame & 1)) {                  // only operate on cells appropriate for this phase
                            var move = null;
                            console.log("DEBUG cell:", xyz, "-----------------------------------");
                            for (i = 0; i < 8; i++) {
                                var d1 = offs1[i];
                                var d2 = offs2[i];
                                console.log("  d1, d2:", d1, d2, "dxyz:", xyz[0] + d1, 0, xyz[2] + d2, "getGrid:", getGrid([xyz[0] + d1, 0, xyz[2] + d2]));
                                if (getGrid([xyz[0] + d1, 0, xyz[2] + d2])) {
                                    var mv = [move1[i], 0, move2[i]];
                                    console.log("  mv:", mv);
                                    if (move == null) {
                                        move = mv;
                                        console.log("  move:", move);
                                    }
                                    else {
                                        if (!v3eq(move, mv)) {
                                            move = false; // conflicting moves -- give up
                                            console.log("  move:", move);
                                        }
                                    }
                                }
                            }
                            console.log("  move:", move);
                        }
                    }
                    render();
                    frame++;
                 }
            }
            
            function v3eq(v1, v2){
                return (v1[0] == v2[0] && v1[1] == v2[1] && v1[2] == v2[2]);
            }

            function moveCell(oldxyz, mesh, newxyz) {
                setObjPosition(mesh, newxyz);
                delGrid(oldxyz);
                putGrid(mesh, newxyz);
            }

            // convert grid coord to 3D coord and set obj.position accordingly given vector [x,y,z]
            function setObjPosition(obj, xyz) {
                obj.position.x = xyz[0] * 50 + 25;
                obj.position.y = xyz[1] * 50 + 25;
                obj.position.z = xyz[2] * 50 + 25;
            }
            
            function setBrushPosition(xyz) {
                setObjPosition(brush, xyz);
                if ((xyz[0] + xyz[1] + xyz[2]) % 2 == 0) {
                    setBrushColor(0);                    
                }
                else {
                    setBrushColor(5);                    
                }
            }

            function putGrid(obj, xyz) {
                grid[xyz] = obj;
            }

            function getGrid(xyz) {
                return grid[xyz];
            }

            function delGrid(xyz) {
                delete grid[xyz];
            }

            function onDocumentKeyDown( event ) {

console.log("key:", event.keyCode);
                switch( event.keyCode ) {
                    case 16: 
                        isShiftDown = true; 
                        interact(); 
                        render(); 
                        break;
                    case 37: 
                        cursor[0]--;
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 38: 
                        cursor[2]--;
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 39: 
                        cursor[0]++;
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 40: 
                        cursor[2]++;
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 85: 
                        cursor[1]++;
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 68: 
                        cursor[1]--;
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 83:
                        isRunning = true;
                        mainLoop();
                        isRunning = false;
                        break;
                    case 32:
                        if (isRunning) {
                            isRunning = false;
                            setBrushPosition(cursor);
                        }
                        else {
                            isRunning = true;
                            setBrushPosition([0,2000,0]);
                        }
                        break;
                    case 10:
                    case 13:
                        var obj = getGrid(cursor);
                        if (obj) {
                            scene.removeObject(obj);
                            delGrid(cursor);
                        }
                        else {
                            var voxel = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ color ] ) );
                            putGrid(voxel, cursor);
                            setObjPosition(voxel, cursor);
                            voxel.overdraw = true;
                            scene.addObject( voxel );
                        }
                        updateHash();
                        render(); 
var temp = [];
for(var e in grid) temp.push(e);
console.log("grid:", temp)
                        break;
                }

            }

            function onDocumentKeyUp( event ) {

                switch( event.keyCode ) {

                    case 16: isShiftDown = false; interact(); render(); break;

                }

            }

            function onDocumentMouseDown( event ) {

                event.preventDefault();

                isMouseDown = true;

                onMouseDownTheta = theta;
                onMouseDownPhi = phi;
                onMouseDownPosition.x = event.clientX;
                onMouseDownPosition.y = event.clientY;

            }

            function onDocumentMouseMove( event ) {

                var dx = event.clientX - onMouseDownPosition.x;
                var dy = event.clientY - onMouseDownPosition.y;
//console.log("dx, dy:", dx, dy)
                event.preventDefault();

                if ( isMouseDown ) {

                    theta = - ( ( event.clientX - onMouseDownPosition.x ) * 0.5 ) + onMouseDownTheta;
                    phi = ( ( event.clientY - onMouseDownPosition.y ) * 0.5 ) + onMouseDownPhi;

                    phi = Math.min( 180, Math.max( 0, phi ) );

                    camera.position.x = radious * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                    camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
                    camera.position.z = radious * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                    camera.updateMatrix();

                }

                mouse3D = projector.unprojectVector( new THREE.Vector3( ( event.clientX / renderer.domElement.width ) * 2 - 1, - ( event.clientY / renderer.domElement.height ) * 2 + 1, 0.5 ), camera );
                ray.direction = mouse3D.subSelf( camera.position ).normalize();

                if(!isMouseDown || Math.sqrt(dx*dx+dy*dy) < 8) {
                    interact();
                }
                render();

            }

            function onDocumentMouseUp( event ) {

                event.preventDefault();

                isMouseDown = false;

                onMouseDownPosition.x = event.clientX - onMouseDownPosition.x;
                onMouseDownPosition.y = event.clientY - onMouseDownPosition.y;

                if ( onMouseDownPosition.length() > 5 ) {
console.log("fergetit")
                    return;

                }

                var intersect, intersects = ray.intersectScene( scene );

                if ( intersects.length > 0 ) {

                    intersect = intersects[ 0 ].object == brush ? intersects[ 1 ] : intersects[ 0 ];

                    if ( intersect ) {

                        if ( isShiftDown ) {

                            if ( intersect.object != plane ) {

                                scene.removeObject( intersect.object );

                            }

                        } else {

                            var position = new THREE.Vector3().add( intersect.point, intersect.object.matrixRotation.transform( intersect.face.normal.clone() ) );

                            var voxel = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ color ] ) );
                            
                            /*
                            voxel.position.x = Math.floor( position.x / 50 ) * 50 + 25;
                            voxel.position.y = Math.floor( position.y / 50 ) * 50 + 25;
                            voxel.position.z = Math.floor( position.z / 50 ) * 50 + 25;
                            */
                            setObjPosition(voxel, cursor);
                            voxel.overdraw = true;
                            scene.addObject( voxel );

                        }

                    }

                }

                updateHash();
                interact();
                render();

            }

            function onDocumentMouseWheel( event ) {

                radious -= event.wheelDeltaY;

                camera.position.x = radious * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
                camera.position.z = radious * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                camera.updateMatrix();

                interact();
                render();

            }

            function setBrushColor( value ) {
                color = value;
                brush.material[ 0 ].color.setHex( colors[ color ] ^ 0x4C000000 );

                render();

            }

            function buildFromHash() {

                var hash = window.location.hash.substr( 1 ),
                version = hash.substr( 0, 2 );

                if ( version == "A/" ) {

                    var current = { x: 0, y: 0, z: 0, c: 0 }
                    var data = decode( hash.substr( 2 ) );
                    var i = 0, l = data.length;

                    while ( i < l ) {

                        var code = data[ i ++ ].toString( 2 );

                        if ( code.charAt( 1 ) == "1" ) current.x += data[ i ++ ] - 32;
                        if ( code.charAt( 2 ) == "1" ) current.y += data[ i ++ ] - 32;
                        if ( code.charAt( 3 ) == "1" ) current.z += data[ i ++ ] - 32;
                        if ( code.charAt( 4 ) == "1" ) current.c += data[ i ++ ] - 32;
                        if ( code.charAt( 0 ) == "1" ) {
                            var voxel = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ current.c ] ) );
                            voxel.position.x = current.x * 50 + 25;
                            voxel.position.y = current.y * 50 + 25;
                            voxel.position.z = current.z * 50 + 25;
                            voxel.overdraw = true;
                            scene.addObject( voxel );
                            putGrid(voxel, [current.x, current.y, current.z])
                        }
                    }

                } else {

                    var data = decode( hash );

                    for ( var i = 0; i < data.length; i += 4 ) {

                        var voxel = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ data[ i + 3 ] ] ) );
                        voxel.position.x = ( data[ i ] - 20 ) * 25;
                        voxel.position.y = ( data[ i + 1 ] + 1 ) * 25;
                        voxel.position.z = ( data[ i + 2 ] - 20 ) * 25;
                        voxel.overdraw = true;
                        scene.addObject( voxel );

                    }

                }

                updateHash();

            }

            function updateHash() {

                var data = [],
                current = { x: 0, y: 0, z: 0, c: 0 },
                last = { x: 0, y: 0, z: 0, c: 0 },
                code;

                for ( var i in scene.objects ) {

                    object = scene.objects[ i ];

                    if ( object instanceof THREE.Mesh && object !== plane && object !== brush ) {

                        current.x = ( object.position.x - 25 ) / 50;
                        current.y = ( object.position.y - 25 ) / 50;
                        current.z = ( object.position.z - 25 ) / 50;
                        current.c = colors.indexOf( object.material[ 0 ].color.hex & 0xffffff );

                        code = 0;

                        if ( current.x != last.x ) code += 1000;
                        if ( current.y != last.y ) code += 100;
                        if ( current.z != last.z ) code += 10;
                        if ( current.c != last.c ) code += 1;

                        code += 10000;

                        data.push( parseInt( code, 2 ) );

                        if ( current.x != last.x ) {

                            data.push( current.x - last.x + 32 );
                            last.x = current.x;

                        }

                        if ( current.y != last.y ) {

                            data.push( current.y - last.y + 32 );
                            last.y = current.y;

                        }

                        if ( current.z != last.z ) {

                            data.push( current.z - last.z + 32 );
                            last.z = current.z;

                        }

                        if ( current.c != last.c ) {

                            data.push( current.c - last.c + 32 );
                            last.c = current.c;

                        }

                    }

                }

                data = encode( data );
                window.location.hash = "A/" + data;
                document.getElementById( 'link' ).href = "http://mrdoob.com/projects/voxels/#A/" + data;

            }

            function interact() {

                if ( objectHovered ) {

                    objectHovered.material[ 0 ].color.a = 1;
                    objectHovered.material[ 0 ].color.updateStyleString();
                    objectHovered = null;

                }

                var position, intersect, intersects = ray.intersectScene( scene );

                if ( intersects.length > 0 ) {

                    intersect = intersects[ 0 ].object != brush ? intersects[ 0 ] : intersects[ 1 ];

                    if ( intersect ) {

                        if ( isShiftDown ) {

                            if ( intersect.object != plane ) {

                                objectHovered = intersect.object;
                                objectHovered.material[ 0 ].color.a = 0.5;
                                objectHovered.material[ 0 ].color.updateStyleString();

                                return;

                            }

                        } else {

                            position = new THREE.Vector3().add( intersect.point, intersect.object.matrixRotation.transform( intersect.face.normal.clone() ) );

                            /*
                            brush.position.x = Math.floor( position.x / 50 ) * 50 + 25;
                            brush.position.y = Math.floor( position.y / 50 ) * 50 + 25;
                            brush.position.z = Math.floor( position.z / 50 ) * 50 + 25;
                            */
                            return;

                        }

                    }

                }

                //brush.position.y = brushY;
                setObjPosition(brush, cursor);

            }

            function render() {

                renderer.render( scene, camera );

            }

            function save() {

                linesMaterial.color.setRGBA( 0, 0, 0, 0 );
                //brush.position.y = brushY;
                setObjPosition(brush, cursor);
                render();

                window.open( renderer.domElement.toDataURL('image/png'), 'mywindow' );

                linesMaterial.color.setRGBA( 0, 0, 0, 0.2 );
                render();

            }

            function clear() {

                if ( !confirm( 'Are you sure?' ) ) {

                    return

                }

                window.location.hash = "";

                var i = 0;

                while ( i < scene.objects.length ) {

                    object = scene.objects[ i ];

                    if ( object instanceof THREE.Mesh && object !== plane && object !== brush ) {

                        scene.removeObject( object );
                        continue;
                    }

                    i ++;
                }

                updateHash();
                render();

            }

            // https://gist.github.com/665235

            function decode( string ) {

                var output = [];
                string.split('').forEach( function ( v ) { output.push( "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf( v ) ); } );
                return output;

            }

            function encode( array ) {

                var output = "";
                array.forEach( function ( v ) { output += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt( v ); } );
                return output;

            }

        </script>

    </body>
</html>
