<!DOCTYPE HTML>
<html lang="en">
    <head>
        <title>NACL demo</title>
        <meta charset="utf-8">
        <style type="text/css">
            body {
                font-family: Monospace;
                font-size: 12px;
                background-color: #f0f0f0;
                margin: 0px;
                overflow: hidden;
            }
        </style>
    </head>
    <body>
        <div style="position:absolute;background-color:white;font-size:large">
            Generation:
            <span id="generation"></span>
            <br/>
            <span id="direction"></span>
            <br/>
            Duplicate:
            <span id="duplicates"></span>
            <br/>
            Hash:
            <span id="showhash" style="font-size:small;"></span>
        </div>
        <script type="text/javascript" src="js/ThreeCanvas.js"></script>
        <script type="text/javascript" src="js/Cube.js"></script>
        <script type="text/javascript" src="js/Plane.js"></script>
        <script type="text/javascript">
            var DEBUG = false;
            var offs1 = [+2, +1, -1, -2, +2, +1, -1, -2];
            var offs2 = [+1, +2, +2, +1, -1, -2, -2, -1];
            var move1 = [+1, -1, +1, -1, +1, -1, +1, -1];
            var move2 = [-1, +1, +1, -1, +1, -1, -1, +1];
            var cursor = [0, 0, 0];
            var grid = {};
            var isRunning = false;
            var direction = "forward";
            var hashmap = {};
            var lasthash = "";
            var frame = 0;
            var container, interval,
            camera, scene, renderer,
            projector, plane, cube, linesMaterial,
            color = 0,colors = [ 0xDF1F1F, 0xDFAF1F, 0x80DF1F, 0x1FDF50, 0x1FDFDF, 0x1F4FDF, 0x7F1FDF, 0xDF1FAF, 0xEFEFEF, 0x303030 ],
            ray, brush, objectHovered,
            mouse3D, isMouseDown = false, onMouseDownPosition,
            radious = 1600, theta = 0, onMouseDownTheta = 45, phi = 75, onMouseDownPhi = 60,
            isShiftDown = false;

            init();
            render();

            function init() {
                if(DEBUG) console.log("init start")
                container = document.createElement( 'div' );
                document.body.appendChild( container );

                var info = document.createElement( 'div' );
                info.style.position = 'absolute';
                info.style.top = '5px';
                info.style.width = '100%';
                info.style.textAlign = 'center';
                info.innerHTML = '<p><span style="color: #444; background-color: #fff; border-bottom: 1px solid #ddd; padding: 8px 10px; font-size:medium">' +
                '<b>click & drag to rotate view | arrows move cursor; U & D for up/down | ENTER to create/delete | S to step | </b>' +
                '<a id="link" href="" target="_blank">share</a> <a href="javascript:save();">save</a> <a href="javascript:clear();">clear</a></span>' +
                '</p><button onclick="toggleRunning()">RUN/STOP</button>' +
                '<button onclick="window.location.reload(true)">RESET</button>' +
                '<button onclick="reverseDirection()">REVERSE</button></br>';
                container.appendChild( info );
 
                camera = new THREE.Camera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
                if(DEBUG) console.log("camera:", camera);
                camera.position.x = radious * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
                camera.position.z = radious * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
//                camera.position.y = 200;

                scene = new THREE.Scene();

                // Grid

                var geometry = new THREE.Geometry();
                geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( - 500, 0, 0 ) ) );
                geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( 500, 0, 0 ) ) );

                linesMaterial = new THREE.LineColorMaterial( 0x000000, 0.2 );

                for ( var i = 0; i <= 20; i ++ ) {

                    var line = new THREE.Line( geometry, linesMaterial );
                    line.position.z = ( i * 50 ) - 500;
                    scene.addObject( line );

                    var line = new THREE.Line( geometry, linesMaterial );
                    line.position.x = ( i * 50 ) - 500;
                    line.rotation.y = 90 * Math.PI / 180;
                    scene.addObject( line );

                }

                projector = new THREE.Projector();

                plane = new THREE.Mesh( new Plane( 1000, 1000 ) );
                plane.rotation.x = - 90 * Math.PI / 180;
                scene.addObject( plane );

                cube = new Cube( 50, 50, 50 );

                ray = new THREE.Ray( camera.position, null );

                brush = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ color ], 0.4 ) );
                //brush.position.y = brushY;
                setObjPosition(brush, cursor);
                brush.overdraw = true;
                scene.addObject( brush );

                onMouseDownPosition = new THREE.Vector2();

                // Lights

                var ambientLight = new THREE.AmbientLight( 0x404040 );
                scene.addLight( ambientLight );

                var directionalLight = new THREE.DirectionalLight( 0xffffff );
                directionalLight.position.x = 1;
                directionalLight.position.y = 1;
                directionalLight.position.z = 0.75;
                directionalLight.position.normalize();
                scene.addLight( directionalLight );

                var directionalLight = new THREE.DirectionalLight( 0x808080 );
                directionalLight.position.x = - 1;
                directionalLight.position.y = 1;
                directionalLight.position.z = - 0.75;
                directionalLight.position.normalize();
                scene.addLight( directionalLight );

                renderer = new THREE.CanvasRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );

                container.appendChild(renderer.domElement);

                document.addEventListener( 'keydown', onDocumentKeyDown, false );
                document.addEventListener( 'keyup', onDocumentKeyUp, false );

                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                document.addEventListener( 'mousedown', onDocumentMouseDown, false );
                document.addEventListener( 'mouseup', onDocumentMouseUp, false );

                document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );

                if ( window.location.hash ) {

                    buildFromHash();
                }

                setInterval(mainLoop, 140);
                render();
            }
            
            function mainLoop() {
                document.getElementById("generation").innerHTML = frame;
                document.getElementById("direction").innerHTML = direction;
                updateHash(true);
                if (isRunning) {
                    if (direction == "reverse") {
                        frame--;
                    }
                    if(DEBUG) console.log("frame:", frame)
                    var cells = [];
                    for(key in grid) {
                        cells.push([key, grid[key]]);
                    }
                    if(DEBUG) console.log("cells:", cells)
                    var moves = []
                    for (var i in cells) {
                        cell = cells[i];
                        if(DEBUG) console.log(cell[0], cell[1]);
                        xyz = eval('[' + cell[0] + ']');
                        
                        if (((xyz[0] + xyz[1] + xyz[2]) & 1) == (frame & 1)) {                  // only operate on cells appropriate for this phase
                            if(DEBUG) console.log("DEBUG cell:", xyz, "-----------------------------------");
                            var x1, x2                                          // our two axes for today
                            switch( (frame % 3 + 3) %3 ) {                      // ach, Javascript you old goat
                                case 0: x1=0; x2=1; break;
                                case 1: x1=1; x2=2; break;
                                case 2: x1=2; x2=0; break;
                            }
                            var move = getMove(xyz, x1, x2);
                            if (move) {
                                var mvto = [xyz[0] + move[0], xyz[1] + move[1], xyz[2] + move[2]];
                                if(!getGrid(mvto)) {
                                    var mv = getMove(mvto, x1, x2);                             // tricky -- read the paper. Can only move if the location we move to would have moved to us (swap)
                                    if (mv && mv[0] + move[0] == 0 && mv[1] + move[1] == 0 && mv[2] + move[2] == 0) {
                                        if(DEBUG) console.log("  mvto:", mvto);
                                        moves.push([xyz, cell[1], mvto]);
                                    }
                                }
                            }
                        }
                    }
                    for (i in moves) {
                        var args = moves[i];
                        moveCell(args[0], args[1], args[2]);
                    }
                    render();
                    if (direction == "forward") {
                        frame++;
                    }
                 }
            }
            
            function getMove(xyz, x1, x2) {
                if(x1 == null) x1 = 0;
                if(x2 == null) x2 = 2;
                var move = null;
                var d = [0, 0, 0]
                for (i = 0; i < 8; i++) {
                    d[x1] = offs1[i];
                    d[x2] = offs2[i];
                    if (getGrid([xyz[0] + d[0], xyz[1] + d[1], xyz[2] + d[2]])) {
                        var mv = [0, 0, 0];
                        mv[x1] = move1[i];
                        mv[x2] = move2[i];
                                                                            if (DEBUG) console.log("  mv:", mv);
                        if (move == null) {
                            move = mv;
                                                                            if (DEBUG) console.log("  move:", move);
                        }
                        else {
                            if (!v3eq(move, mv)) {
                                move = false;                               // conflicting moves -- give up
                                                                            if (DEBUG) console.log("  move:", move);
                                break;
                            }
                        }
                    }
                }
                return move
            }
            
            function v3eq(v1, v2){
                return (v1[0] == v2[0] && v1[1] == v2[1] && v1[2] == v2[2]);
            }

            function moveCell(oldxyz, mesh, newxyz) {
                setObjPosition(mesh, newxyz);
                delGrid(oldxyz);
                putGrid(mesh, newxyz);
            }

            // convert grid coord to 3D coord and set obj.position accordingly given vector [x,y,z]
            function setObjPosition(obj, xyz) {
                obj.position.x = xyz[0] * 50 + 25;
                obj.position.y = xyz[1] * 50 + 25;
                obj.position.z = xyz[2] * 50 + 25;
            }
            
            function setBrushPosition(xyz) {
                setObjPosition(brush, xyz);
                if ((xyz[0] + xyz[1] + xyz[2]) % 2 == 0) {
                    setBrushColor(0);                    
                }
                else {
                    setBrushColor(5);                    
                }
            }

            function putGrid(obj, xyz) {
                grid[xyz] = obj;
            }

            function getGrid(xyz) {
                return grid[xyz];
            }

            function delGrid(xyz) {
                delete grid[xyz];
            }
            
            function toggleRunning(){
                if (isRunning) {
                    cursor = [0, 0, 0];
                    isRunning = false;
                }
                else {
                    cursor = [0, 2000, 0];
                    isRunning = true;
                }
                setBrushPosition(cursor);
            }

            function reverseDirection(){
                hashmap = {}
                document.getElementById("duplicates").innerHTML = "";
                if (direction == "forward") {
                    direction = "reverse";
                }
                else {
                    direction = "forward";
                }
                updateHash(true);
            }

            function onDocumentKeyDown( event ) {

if(DEBUG) console.log("key:", event.keyCode);
                switch( event.keyCode ) {
                    case 16: 
                        isShiftDown = true; 
                        interact(); 
                        render(); 
                        break;
                    case 37: 
                        cursor[0]--;
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 38: 
                        cursor[2]--;
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 39: 
                        cursor[0]++;
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 40: 
                        cursor[2]++;
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 85: 
                        cursor[1]++;
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 68: 
                        cursor[1]--;
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 83:
                        isRunning = true;
                        mainLoop();
                        isRunning = false;
                        break;
                    case 32:
                        toggleRunning();
                        break;
                    case 10:
                    case 13:
                        var obj = getGrid(cursor);
                        if (obj) {
                            scene.removeObject(obj);
                            delGrid(cursor);
                        }
                        else {
                            var voxel = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ color ] ) );
                            putGrid(voxel, cursor);
                            setObjPosition(voxel, cursor);
                            voxel.overdraw = true;
                            scene.addObject( voxel );
                        }
                        updateHash();
                        render(); 
var temp = [];
for(var e in grid) temp.push(e);
if(DEBUG) console.log("grid:", temp)
                        break;
                }

            }

            function onDocumentKeyUp( event ) {

                switch( event.keyCode ) {

                    case 16: isShiftDown = false; interact(); render(); break;

                }

            }

            function onDocumentMouseDown( event ) {

                event.preventDefault();

                isMouseDown = true;

                onMouseDownTheta = theta;
                onMouseDownPhi = phi;
                onMouseDownPosition.x = event.clientX;
                onMouseDownPosition.y = event.clientY;

            }

            function onDocumentMouseMove( event ) {

                var dx = event.clientX - onMouseDownPosition.x;
                var dy = event.clientY - onMouseDownPosition.y;
//if(DEBUG) console.log("dx, dy:", dx, dy)
                event.preventDefault();

                if ( isMouseDown ) {

                    theta = - ( ( event.clientX - onMouseDownPosition.x ) * 0.5 ) + onMouseDownTheta;
                    phi = ( ( event.clientY - onMouseDownPosition.y ) * 0.5 ) + onMouseDownPhi;

                    phi = Math.min( 180, Math.max( 0, phi ) );

                    camera.position.x = radious * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                    camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
                    camera.position.z = radious * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                    if(DEBUG) console.log("camera:", camera.position)
                    camera.updateMatrix();

                }

                mouse3D = projector.unprojectVector( new THREE.Vector3( ( event.clientX / renderer.domElement.width ) * 2 - 1, - ( event.clientY / renderer.domElement.height ) * 2 + 1, 0.5 ), camera );
                ray.direction = mouse3D.subSelf( camera.position ).normalize();

                if(!isMouseDown || Math.sqrt(dx*dx+dy*dy) < 8) {
                    interact();
                }
                render();

            }

            function onDocumentMouseUp( event ) {

                event.preventDefault();

                isMouseDown = false;

                onMouseDownPosition.x = event.clientX - onMouseDownPosition.x;
                onMouseDownPosition.y = event.clientY - onMouseDownPosition.y;

            }

            function onDocumentMouseWheel( event ) {

                radious -= event.wheelDeltaY;

                camera.position.x = radious * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
                camera.position.z = radious * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                camera.updateMatrix();

                interact();
                render();

            }

            function setBrushColor( value ) {
                color = value;
                brush.material[ 0 ].color.setHex( colors[ color ] ^ 0x4C000000 );

                render();

            }

            function buildFromHash() {

                var hash = window.location.hash.substr( 1, window.location.hash.length-2 ),
                version = hash.substr( 0, 2 );

                if ( version == "A/" ) {

                    var current = { x: 0, y: 0, z: 0, c: 0 }
                    var data = decode( hash.substr( 2 ) );
                    var i = 0, l = data.length;

                    while ( i < l ) {

                        var code = data[ i ++ ].toString( 2 );

                        if ( code.charAt( 1 ) == "1" ) current.x += data[ i ++ ] - 32;
                        if ( code.charAt( 2 ) == "1" ) current.y += data[ i ++ ] - 32;
                        if ( code.charAt( 3 ) == "1" ) current.z += data[ i ++ ] - 32;
                        if ( code.charAt( 4 ) == "1" ) current.c += data[ i ++ ] - 32;
                        if ( code.charAt( 0 ) == "1" ) {
                            var voxel = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ current.c ] ) );
                            voxel.position.x = current.x * 50 + 25;
                            voxel.position.y = current.y * 50 + 25;
                            voxel.position.z = current.z * 50 + 25;
                            voxel.overdraw = true;
                            scene.addObject( voxel );
                            putGrid(voxel, [current.x, current.y, current.z])
                        }
                    }

                } else {

                    var data = decode( hash );

                    for ( var i = 0; i < data.length; i += 4 ) {

                        var voxel = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ data[ i + 3 ] ] ) );
                        voxel.position.x = ( data[ i ] - 20 ) * 25;
                        voxel.position.y = ( data[ i + 1 ] + 1 ) * 25;
                        voxel.position.z = ( data[ i + 2 ] - 20 ) * 25;
                        voxel.overdraw = true;
                        scene.addObject( voxel );

                    }

                }

                updateHash();

            }

            function updateHash(noLink) {

                var data = [],
                current = { x: 0, y: 0, z: 0, c: 0 },
                last = { x: 0, y: 0, z: 0, c: 0 },
                code;

                for ( var i in scene.objects ) {

                    object = scene.objects[ i ];

                    if ( object instanceof THREE.Mesh && object !== plane && object !== brush ) {

                        current.x = ( object.position.x - 25 ) / 50;
                        current.y = ( object.position.y - 25 ) / 50;
                        current.z = ( object.position.z - 25 ) / 50;
                        current.c = colors.indexOf( object.material[ 0 ].color.hex & 0xffffff );

                        code = 0;

                        if ( current.x != last.x ) code += 1000;
                        if ( current.y != last.y ) code += 100;
                        if ( current.z != last.z ) code += 10;
                        if ( current.c != last.c ) code += 1;

                        code += 10000;

                        data.push( parseInt( code, 2 ) );

                        if ( current.x != last.x ) {

                            data.push( current.x - last.x + 32 );
                            last.x = current.x;

                        }

                        if ( current.y != last.y ) {

                            data.push( current.y - last.y + 32 );
                            last.y = current.y;

                        }

                        if ( current.z != last.z ) {

                            data.push( current.z - last.z + 32 );
                            last.z = current.z;

                        }

                        if ( current.c != last.c ) {

                            data.push( current.c - last.c + 32 );
                            last.c = current.c;

                        }

                    }

                }

                data = encode( data );
                data += (frame % 6 + 6) %6
                if (!noLink) {
                    window.location.hash = "A/" + data;
                    document.getElementById('link').href = "http://mrdoob.com/projects/voxels/#A/" + data;
                }
                document.getElementById('showhash').innerHTML = data;
                if (data != lasthash) {
                    if (data in hashmap) {
                        document.getElementById("duplicates").innerHTML = frame + "=" + hashmap[data];
                    }
                }
                hashmap[data] = frame;
                lasthash = data;
            }

            function interact() {

                if ( objectHovered ) {

                    objectHovered.material[ 0 ].color.a = 1;
                    objectHovered.material[ 0 ].color.updateStyleString();
                    objectHovered = null;

                }

                var position, intersect, intersects = ray.intersectScene( scene );

                if ( intersects.length > 0 ) {

                    intersect = intersects[ 0 ].object != brush ? intersects[ 0 ] : intersects[ 1 ];

                    if ( intersect ) {

                        if ( isShiftDown ) {

                            if ( intersect.object != plane ) {

                                objectHovered = intersect.object;
                                objectHovered.material[ 0 ].color.a = 0.5;
                                objectHovered.material[ 0 ].color.updateStyleString();

                                return;

                            }

                        } else {

                            position = new THREE.Vector3().add( intersect.point, intersect.object.matrixRotation.transform( intersect.face.normal.clone() ) );

                            /*
                            brush.position.x = Math.floor( position.x / 50 ) * 50 + 25;
                            brush.position.y = Math.floor( position.y / 50 ) * 50 + 25;
                            brush.position.z = Math.floor( position.z / 50 ) * 50 + 25;
                            */
                            return;

                        }

                    }

                }

                //brush.position.y = brushY;
                setObjPosition(brush, cursor);

            }

            function render() {

                renderer.render( scene, camera );

            }

            function save() {

                linesMaterial.color.setRGBA( 0, 0, 0, 0 );
                //brush.position.y = brushY;
                setObjPosition(brush, cursor);
                render();

                window.open( renderer.domElement.toDataURL('image/png'), 'mywindow' );

                linesMaterial.color.setRGBA( 0, 0, 0, 0.2 );
                render();

            }

            function clear() {

                if ( !confirm( 'Are you sure?' ) ) {

                    return

                }

                window.location.hash = "";

                var i = 0;

                while ( i < scene.objects.length ) {

                    object = scene.objects[ i ];

                    if ( object instanceof THREE.Mesh && object !== plane && object !== brush ) {

                        scene.removeObject( object );
                        continue;
                    }

                    i ++;
                }

                updateHash();
//                render();
                window.location.reload(true);
            }

            // https://gist.github.com/665235

            function decode( string ) {

                var output = [];
                string.split('').forEach( function ( v ) { output.push( "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf( v ) ); } );
                return output;

            }

            function encode( array ) {

                var output = "";
                array.forEach( function ( v ) { output += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt( v ); } );
                return output;

            }

        </script>

    </body>
</html>
