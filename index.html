<!DOCTYPE HTML>
<html lang="en">
    <head>
        <!--
        The MIT License
        
        Copyright (c) 2010-2012 danx0r (Daniel B. Miller), Authors of three.js. 
        All rights reserved.
        
        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:
        
        The above copyright notice and this permission notice shall be included in
        all copies or substantial portions of the Software.
        
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        THE SOFTWARE.
        -->
        <title>BUSY BOXES</title>
        <meta charset="utf-8">
        <style type="text/css">
            body {
                font-family: Monospace;
                font-size: 12px;
                background-color: #f0f0f0;
                margin: 0px;
                overflow: hidden;
            }
        </style>
    </head>
    <style>
        .goHash {
            font-family:monospace;
            font-size:large;
            #color:blue;
            #background:none;
            border:none;
            padding:0;
            #border-bottom:1px solid;
            background-color:#ddd;
            opacity:0.7;
        }
    </style>
    <body>
        <div style="position:absolute;font-size:large">
            Generation:
            <span id="generation"></span>
            <br/>
            phase:
            <span id="showphase"></span>
            <br/>
            Direction:
            <span id="direction"></span>
            <br/>
            Duplicate:
            <span id="duplicates"></span>
            <br/>
            <!--
            Hash:
            <span id="showhash" style="font-size:small;"></span>
            <br/>
            -->
            Cells:
            <span id="cellcount"></span>
            <br/>
            Cursor:
            <span id="cursorpos"></span>
            <br/>
            <br/>
            <button class="goHash" id="introHash" onclick="selectHash('PeciXwDuTA0', this)">Intro</button>
            <br/>
            <button class="goHash" onclick="selectHash('GJR0', this)">Glider 1</button>
            <br/>
            <button class="goHash" onclick="selectHash('UMlSpB0', this)">Glider 2</button>
            <br/>
            <button class="goHash" onclick="selectHash('IYKmDcRzB0', this)">Glider 3</button>
            <br/>
            <button class="goHash" onclick="selectHash('IYKmDIA0', this)">Glider 4</button>
            <br/>
            <button class="goHash" onclick="selectHash('PB0jwU0vAB0', this)">Glider 5</button>
            <br/>
            <button class="goHash" onclick="selectHash('PR0cME0nAA0', this)">Glider 6</button>
            <br/>
            <button class="goHash" onclick="selectHash('IFIWA0', this)">Cycle 1 (12)</button>
            <br/>
            <button class="goHash" onclick="selectHash('csmKB0', this)">Cycle 2 (12)</button>
            <br/>
            <button class="goHash" onclick="selectHash('AQGk0', this)">Cycle 3 (24)</button>
            <br/>
            <button class="goHash" onclick="selectHash('BwF6Ao40', this)">Cycle 4 (36)</button>
            <br/>
            <button class="goHash" onclick="selectHash('UMXTUukA0', this)">Cycle 5 (42)</button>
            <br/>
            <button class="goHash" onclick="selectHash('ACRAs0', this)">Cycle 6 (60)</button>
            <br/>
            <button class="goHash" onclick="selectHash('IQEEcwBBHA0', this)">Cycle 7 (84)</button>
            <br/>
            <button class="goHash" onclick="selectHash('IDYCyj0B5', this)">Cycle 8 (144)</button>
            <br/>
            <button class="goHash" onclick="selectHash('cICOg2CB0', this)">Cycle 9 (582)</button>
            <br/>
            <button class="goHash" onclick="selectHash('sICMBZBAULIB0', this)">Cycle 10 (3966)</button>
            <br/>
            <button class="goHash" onclick="selectHash('Tc9FLA0', this)">Boomerang (60)</button>
            <br/>
            <button class="goHash" onclick="selectHash('HS8UNxTp0', this)">Deflect (Routing)</button>
            <br/>
            <button class="goHash" onclick="selectHash('XUcUN4Ab3pB0', this)">Logic (Interaction Gate)</button>
            <br/>
            <button class="goHash" onclick="selectHash('cs6dxwG0', this)">Move</button>
            <br/>
            <button class="goHash" onclick="selectHash('MLDQ3S82JzTA0', this)">Fast and Slow</button>
            <br/>
            <button class="goHash" onclick="selectHash('EAHuexNzTmB0', this)">Capture and emit</button>
            <br/>
            <button class="goHash" onclick="selectHash('QAgIjoICCzCBB0', this)">Delayed release</button>
            <br/>
            <button class="goHash" onclick="selectHash('vwB3JyPaCCCPQCCCPQCCCPQCCD1dPHzPM0', this)">Attraction</button>
            <br/>
            <button class="goHash" onclick="selectHash('MnCTi7uMxOftTl7px47ec4vgSHgMH4FTu5zo-AZk5eecBOvjnR8BSU5ecunSHFwcvwEh4BOm.APh4eTqSB0', this)">Order Out of Chaos</button>
            <br/>
            <button class="goHash" onclick="selectHash('UHfALungB5AgUEEegIFBBHoCBwAj0BAoII9AQKCDydXwCsA0', this)">Structure And Decay</button>
            <br/>
            <button class="goHash" onclick="selectHash('UkDEoQIHETAnBgQo9IUYECBwzo6Q4AQSdAUmCBDhoQOAcCCDOjoIBAgcAUmCnB0CBAgcQ9Abg6KHATBSdAYOE4OkUUIFBejBAgcIJOgIEDgBBJ1BwnBgwcQ9AUY9ACToCBxE6QoIJwdIcI9IUKPQECBwBB0', this)">
                Big Bang (Entropy)</button>
            <br/>
        </div>
        <div style="display:none">
            <div id="banner">
                <a href="faq.html" target="_blank" style="position:absolute;top:-3px;right:12px;font-size:large">faq</a>
                <span style="background-color: #fff; opacity:0.5; border-bottom: 1px solid #ddd; padding: 8px 10px; font-size:medium">
                    <b>click & drag to rotate view | arrows move cursor; U & D for up/down | ENTER to create/delete | S to step</b>
                </span>
                <div style="opacity:0.7">
                    </p><button onclick="toggleRunning()">RUN/STOP</button>
                    <button onclick="fastSlow()">FAST/SLOW</button>
                    <button onclick="reverseDirection()">DIRECTION</button>
                    <button onclick="randomCells(12, -2, 1)">RANDOM</button>
                    <button onclick="playStopMusic()">MUSIC</button>
                    <button onclick="clearGrid()">CLEAR</button>
                    <button onclick="update()">UPDATE</button>
                    <button onclick="reset()">RESET</button>
                </div>
            </div>
        </div>
        <audio id="music" src="prisoner_ambient003.ogg" loop="true"></audio>
        <script type="text/javascript" src="js/ThreeCanvas.js"></script>
        <script type="text/javascript" src="js/Cube.js"></script>
        <script type="text/javascript" src="js/Plane.js"></script>
        <script type="text/javascript" src="js/encdec.js"></script>
        <script type="text/javascript">
            var DEBUG = false;
            var offs1 = [+2, +1, -1, -2, +2, +1, -1, -2];
            var offs2 = [+1, +2, +2, +1, -1, -2, -2, -1];
            var move1 = [+1, -1, +1, -1, +1, -1, +1, -1];
            var move2 = [-1, +1, +1, -1, +1, -1, -1, +1];
            var cursor = [0, 0, 0];
            var gLastCursor = cursor;
            var grid = {};
            var isRunning = false;
            var direction = "forward";
            var hashmap = {};
            var lasthash = "";
            var gUpdateHash = "";
            var encodeString = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-";
            var frame = 0;
            var cellCount = 0;
            var mode = "mirror";
            var axisMin = -12;
            var axisMax = 11;
            var processSpeed = "slow";
            var lastSelectedEl;
            var gLastRefreshedUrl;
            var container, interval,
            camera, scene, renderer,
            projector, plane, cube, linesMaterial,
            color = 0,colors = [ 0xDF1F1F, 0xDFAF1F, 0x80DF1F, 0x1FDF50, 0x1FDFDF, 0x1F4FDF, 0x7F1FDF, 0xDF1FAF, 0xEFEFEF, 0x303030 ],
            ray, brush, objectHovered,
            mouse3D, isMouseDown = false, onMouseDownPosition,
            radious = 2000, theta = 0, onMouseDownTheta = 45, phi = 60, onMouseDownPhi = 60;
            init();
            render();

            function parseQueryArgs() {
                var queryArgs = {};
                var searchString = document.URL;
                var i = searchString.indexOf("?");
                if (i < 0) return queryArgs;
                searchString = searchString.substr(i + 1);
                i = searchString.indexOf("/");
                if (i < 0) {
                    i = searchString.indexOf("#");
                }
                if (i < 0) {
                    i = searchString.length;
                }
                searchString = searchString.substr(0, i);
                var queryArgList = searchString.substr(searchString).split("&");
                for (var i = 0; i < queryArgList.length; i++) {
                    var query = queryArgList[i];
                    var keyval = query.split("=");
                    var key = keyval[0];
                    if (keyval.length <= 1) keyval.push(true);
                    queryArgs[key] = keyval[1];
                }
                return queryArgs;
            }

            function init() {
                if (DEBUG) console.log("init start")
                var qargs = parseQueryArgs();
                if (qargs.size) {
                    var size = parseInt(qargs.size);
                    axisMax = parseInt(size / 2) - 1;
                    axisMin = axisMax - (size - 1);
                    radious *= size/24.0;
                }
                if (DEBUG) console.log("DEBUG query args:", qargs, "axisMax:", axisMax, "axisMin:", axisMin)
                container = document.createElement( 'div' );
                document.body.appendChild( container );

                var info = document.createElement( 'div' );
                info.style.position = 'absolute';
                info.style.top = '5px';
                info.style.width = '100%';
                info.style.textAlign = 'center';
                info.innerHTML = document.getElementById("banner").innerHTML;
                container.appendChild( info );
 
                camera = new THREE.Camera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
                if(DEBUG) console.log("camera:", camera);
                camera.position.x = radious * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
                camera.position.z = radious * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
//                camera.position.y = 200;

                scene = new THREE.Scene();

                // Grid

                var geometry = new THREE.Geometry();
                geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( axisMin * 50, 0, 0 ) ) );
                geometry.vertices.push( new THREE.Vertex( new THREE.Vector3( (axisMax+1) * 50, 0, 0 ) ) );

                linesMaterial = new THREE.LineColorMaterial( 0x000000, 0.2 );

                for ( var i = 0; i <= axisMax - axisMin + 1; i ++ ) {

                    var line = new THREE.Line( geometry, linesMaterial );
                    line.position.z = ( i * 50 ) + axisMin * 50;
                    scene.addObject( line );

                    var line = new THREE.Line( geometry, linesMaterial );
                    line.position.x = ( i * 50 ) + axisMin * 50;
                    line.rotation.y = 90 * Math.PI / 180;
                    scene.addObject( line );

                }

                projector = new THREE.Projector();

                plane = new THREE.Mesh( new Plane( 1000, 1000 ) );
                plane.rotation.x = - 90 * Math.PI / 180;
                scene.addObject( plane );

                cube = new Cube( 50, 50, 50 );

                ray = new THREE.Ray( camera.position, null );

                brush = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ color ], 0.4 ) );
                //brush.position.y = brushY;
                setObjPosition(brush, cursor);
                brush.overdraw = true;
                scene.addObject( brush );

                onMouseDownPosition = new THREE.Vector2();

                // Lights

                var ambientLight = new THREE.AmbientLight( 0x404040 );
                scene.addLight( ambientLight );

                var directionalLight = new THREE.DirectionalLight( 0xffffff );
                directionalLight.position.x = 1;
                directionalLight.position.y = 1;
                directionalLight.position.z = 0.75;
                directionalLight.position.normalize();
                scene.addLight( directionalLight );

                var directionalLight = new THREE.DirectionalLight( 0x808080 );
                directionalLight.position.x = - 1;
                directionalLight.position.y = 1;
                directionalLight.position.z = - 0.75;
                directionalLight.position.normalize();
                scene.addLight( directionalLight );

                renderer = new THREE.CanvasRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );

                container.appendChild(renderer.domElement);

                document.addEventListener( 'keydown', onDocumentKeyDown, false );

                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                document.addEventListener( 'mousedown', onDocumentMouseDown, false );
                document.addEventListener( 'mouseup', onDocumentMouseUp, false );

                document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );
                document.addEventListener( 'DOMMouseScroll', onDocumentMouseWheel, false );

                if ( window.location.hash ) {
                    buildFromHash();
                }

                if (qargs.hash) {
                    buildFromHash(qargs.hash);
                }
                else {
                    selectHash('PeciXwDuTA0', document.getElementById("introHash"));
                }                

                setInterval(mainLoopFast, 14);
                setInterval(mainLoopSlow, 140);
                render();
            }
            
            function mainLoopFast() {
                if (processSpeed == "fast") {
                    mainLoop();
                }
            }
            
            function mainLoopSlow() {
                if (processSpeed == "slow") {
                    mainLoop();
                }
            }
            
            function mainLoop() {
                document.getElementById("generation").innerHTML = frame;
                document.getElementById("showphase").innerHTML = (frame % 6 + 6) %6;
                document.getElementById("direction").innerHTML = direction;
                if (isRunning) {
                    updateHash(true);
                    if (direction == "reverse") {
                        frame--;
                    }
                    if(DEBUG) console.log("frame:", frame)
                    var cells = [];
                    for(key in grid) {
                        cells.push([key, grid[key]]);
                    }
                    if(DEBUG) console.log("cells:", cells)
                    var moves = []
                    var x1, x2                                          // our two axes for today
                    switch( (frame % 3 + 3) %3 ) {                      // ach, Javascript you old goat
                        case 0: x1=0; x2=1; break;
                        case 1: x1=1; x2=2; break;
                        case 2: x1=2; x2=0; break;
                    }
                    if (DEBUG) console.log("frame:", frame, "parity:", frame & 1, ['red','blue'][frame & 1], ['x','y','z'][x1], ['x','y','z'][x2])
                    for (var i in cells) {
                        cell = cells[i];
                        if(DEBUG) console.log(cell[0], cell[1]);
                        xyz = eval('[' + cell[0] + ']');
                        
                        if (((xyz[0] + xyz[1] + xyz[2]) & 1) == (frame & 1)) {                  // only operate on cells appropriate for this phase
                            if(DEBUG) console.log("DEBUG cell:", xyz, "-----------------------------------");
                            var move = getMove(xyz, x1, x2);
                            if (move) {
                                var mvto = [xyz[0] + move[0], xyz[1] + move[1], xyz[2] + move[2]];
                                if(!getGrid(mvto)) {
                                    var mv = getMove(mvto, x1, x2);                             // tricky -- read the paper. Can only move if the location we move to would have moved to us (swap)
                                    if (mv && mv[0] + move[0] == 0 && mv[1] + move[1] == 0 && mv[2] + move[2] == 0) {
                                        if(DEBUG) console.log("  mvto:", mvto);
                                        moves.push([xyz, cell[1], mvto]);
                                    }
                                }
                            }
                        }
                    }
                    for (i in moves) {
                        var args = moves[i];
                        moveCell(args[0], args[1], args[2]);
                    }
                    render();
                    if (direction == "forward") {
                        frame++;
                    }
                 }
            }
            
            function getMove(xyz, x1, x2) {
                if(x1 == null) x1 = 0;
                if(x2 == null) x2 = 2;
                var move = null;
                var d = [0, 0, 0]
                for (i = 0; i < 8; i++) {
                    d[x1] = offs1[i];
                    d[x2] = offs2[i];
                    if (getGrid([xyz[0] + d[0], xyz[1] + d[1], xyz[2] + d[2]])) {
                        var mv = [0, 0, 0];
                        mv[x1] = move1[i];
                        mv[x2] = move2[i];
                                                                            if (DEBUG) console.log("  mv:", mv);
                        if (move == null) {
                            move = mv;
                                                                            if (DEBUG) console.log("  move:", move);
                        }
                        else {
                            if (!v3eq(move, mv)) {
                                move = false;                               // conflicting moves -- give up
                                                                            if (DEBUG) console.log("  move:", move);
                                break;
                            }
                        }
                    }
                }
                if (move && mode == "mirror") {
                    for (var axis = 0; axis < 3; axis++) {
                        if (xyz[axis] + move[axis] > axisMax) {
                            move = false;
                            break;
                        }
                        if (xyz[axis] + move[axis] < axisMin) {
                            move = false;
                            break;
                        }
                    }
                }
                return move
            }
            
            function v3eq(v1, v2){
                return (v1[0] == v2[0] && v1[1] == v2[1] && v1[2] == v2[2]);
            }

            function moveCell(oldxyz, mesh, newxyz) {
                setObjPosition(mesh, newxyz);
                delGrid(oldxyz);
                putGrid(mesh, newxyz);
            }

            // convert grid coord to 3D coord and set obj.position accordingly given vector [x,y,z]
            function setObjPosition(obj, xyz) {
                obj.position.x = xyz[0] * 50 + 25;
                obj.position.y = xyz[1] * 50 + 25;
                obj.position.z = xyz[2] * 50 + 25;
            }
            
            function setBrushPosition(xyz) {
                setObjPosition(brush, xyz);
                if ((xyz[0] + xyz[1] + xyz[2]) % 2 == 0) {
                    setBrushColor(0);                    
                }
                else {
                    setBrushColor(5);                    
                }
                document.getElementById("cursorpos").innerHTML = xyz[0] + "," + xyz[1] + "," + xyz[2]
            }

            function putGrid(obj, xyz) {
                grid[xyz] = obj;
            }

            function getGrid(xyz) {
                return grid[xyz];
            }

            function delGrid(xyz) {
                delete grid[xyz];
            }
            
            function toggleRunning(){
                if (isRunning) {
                    cursor = gLastCursor;
                    isRunning = false;
                }
                else {
                    gLastCursor = cursor;
                    cursor = [0, 2000, 0];
                    isRunning = true;
                }
                setBrushPosition(cursor);
            }
            
            function clampCursor() {
                for (var x=0; x<3; x++) {
                    if (cursor[x] < axisMin) cursor[x] = axisMin;
                    if (cursor[x] > axisMax) cursor[x] = axisMax;
                }
            }

            function reverseDirection(){
                hashmap = {}
                document.getElementById("duplicates").innerHTML = "";
                if (direction == "forward") {
                    direction = "reverse";
                }
                else {
                    direction = "forward";
                }
                updateHash(true);
            }

            function onDocumentKeyDown( event ) {

if(DEBUG) console.log("key:", event.keyCode);
                switch( event.keyCode ) {
                    case 37: 
                        cursor[0]--;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 38: 
                        cursor[2]--;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 39: 
                        cursor[0]++;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 40: 
                        cursor[2]++;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 85: 
                        cursor[1]++;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 68: 
                        cursor[1]--;
                        clampCursor();
                        setBrushPosition(cursor);
                        render(); 
                        break;
                    case 82:
                        reset();
                        break;
                    case 83:
                        isRunning = true;
                        mainLoop();
                        isRunning = false;
                        break;
                    case 32:
                        toggleRunning();
                        break;
                    case 70:
                        processSpeed = "fast";
                        if (!isRunning) {
                            toggleRunning();
                        }
                        break;
                    case 10:
                    case 13:
                        var obj = getGrid(cursor);
                        if (obj) {
                            scene.removeObject(obj);
                            delGrid(cursor);
                        }
                        else {
                            var voxel = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ color ] ) );
                            putGrid(voxel, cursor);
                            setObjPosition(voxel, cursor);
                            voxel.overdraw = true;
                            scene.addObject( voxel );
                        }
                        updateHash();
                        render(); 
                        break;
                }

            }

            function onDocumentMouseDown( event ) {

                event.preventDefault();

                isMouseDown = true;

                onMouseDownTheta = theta;
                onMouseDownPhi = phi;
                onMouseDownPosition.x = event.clientX;
                onMouseDownPosition.y = event.clientY;

            }

            function onDocumentMouseMove( event ) {

                var dx = event.clientX - onMouseDownPosition.x;
                var dy = event.clientY - onMouseDownPosition.y;
//if(DEBUG) console.log("dx, dy:", dx, dy)
                event.preventDefault();

                if ( isMouseDown ) {

                    theta = - ( ( event.clientX - onMouseDownPosition.x ) * 0.5 ) + onMouseDownTheta;
                    phi = ( ( event.clientY - onMouseDownPosition.y ) * 0.5 ) + onMouseDownPhi;

                    phi = Math.min( 180, Math.max( 0, phi ) );

                    camera.position.x = radious * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                    camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
                    camera.position.z = radious * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                    if(DEBUG) console.log("camera:", camera.position)
                    camera.updateMatrix();

                }

                mouse3D = projector.unprojectVector( new THREE.Vector3( ( event.clientX / renderer.domElement.width ) * 2 - 1, - ( event.clientY / renderer.domElement.height ) * 2 + 1, 0.5 ), camera );
                ray.direction = mouse3D.subSelf( camera.position ).normalize();

                render();

            }

            function onDocumentMouseUp( event ) {

                event.preventDefault();

                isMouseDown = false;

                onMouseDownPosition.x = event.clientX - onMouseDownPosition.x;
                onMouseDownPosition.y = event.clientY - onMouseDownPosition.y;

            }

            function onDocumentMouseWheel( event ) {
				if (event.detail) {							/// ugh, dumb Firefox hack
					if (event.detail > 0) {
						radious += 120;
					}
					else {
						radious -= 120;
					}
				}
				else {
	                radious -= event.wheelDeltaY;
				}
            	if (DEBUG) console.log("mw ev:", radious)

                camera.position.x = radious * Math.sin( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                camera.position.y = radious * Math.sin( phi * Math.PI / 360 );
                camera.position.z = radious * Math.cos( theta * Math.PI / 360 ) * Math.cos( phi * Math.PI / 360 );
                camera.updateMatrix();

                render();

            }

            function setBrushColor( value ) {
                color = value;
                brush.material[ 0 ].color.setHex( colors[ color ] ^ 0x4C000000 );

                render();

            }

            function refreshUrl(url) {
                //console.log("should refresh:", url);
                if (history.pushState) {
                    if(url != gLastRefreshedUrl) {
                        history.pushState(url, url, url);
                    }
                    gLastRefreshedUrl = url;
                }
                else {
                    document.location = url;
                }
            }

            function buildFromHash(hash) {
                var version = false;
                if (hash) {
                    version = "Y"; 
                }
                else {
                    version = window.location.hash.substr(1, 1);
                    hash = window.location.hash.substr(3);
                }
                var phase = hash.substr(hash.length-1, hash.length);
                frame = parseInt(phase);
                if ('' + frame == "NaN") {
                    frame = 0;
                }
                else {
                    hash = hash.substr( 0, hash.length - 1 );
                }

                if ( version == "A" ) {

                    var current = { x: 0, y: 0, z: 0, c: 0 }
                    var data = decode( hash );
                    var i = 0, l = data.length;

                    while ( i < l ) {

                        var code = data[ i ++ ].toString( 2 );

                        if ( code.charAt( 1 ) == "1" ) current.x += data[ i ++ ] - 32;
                        if ( code.charAt( 2 ) == "1" ) current.y += data[ i ++ ] - 32;
                        if ( code.charAt( 3 ) == "1" ) current.z += data[ i ++ ] - 32;
                        if ( code.charAt( 4 ) == "1" ) current.c += data[ i ++ ] - 32;
                        if ( code.charAt( 0 ) == "1" ) {
                            var voxel = new THREE.Mesh( cube, new THREE.MeshColorFillMaterial( colors[ current.c ] ) );
                            voxel.position.x = current.x * 50 + 25;
                            voxel.position.y = current.y * 50 + 25;
                            voxel.position.z = current.z * 50 + 25;
                            voxel.overdraw = true;
                            scene.addObject( voxel );
                            putGrid(voxel, [current.x, current.y, current.z])
                        }
                    }

                } else {
                    if (version == "X") {
                        var data = hash;
                        var cur = [0, 0, 0];
                        var x = 0;
                        var delta, sign;
                        while (x < data.length) {
                            for (var i = 0; i < 3; i++) {
                                if (data.charAt(x) == "_") {
                                    x++;
                                    delta = encodeString.indexOf(data.charAt(x++));
                                    sign = 1;
                                    if (delta >= 32) {
                                        sign = -1;
                                    }
                                    delta = (delta & 0x1f) << 6;
                                    delta += encodeString.indexOf(data.charAt(x++))
                                    delta *= sign;
                                }
                                else {
                                    delta = encodeString.indexOf(data.charAt(x++)) - 32;
                                }
                                cur[i] += delta;
                            }
                            var parity = (cur[0] + cur[1] + cur[2]) & 1;
                            var voxel = new THREE.Mesh(cube, new THREE.MeshColorFillMaterial(colors[parity * 5]));
                            voxel.position.x = cur[0] * 50 + 25;
                            voxel.position.y = cur[1] * 50 + 25;
                            voxel.position.z = cur[2] * 50 + 25;
                            voxel.overdraw = true;
                            scene.addObject(voxel);
                            putGrid(voxel, cur);
                        }
                    }
                    else {
                        if (version == "Y") {
                            var data = hash;
                            data = encdec_decode(data);
                            var cur = [0, 0, 0];
                            var x = 0;
                            var delta, sign;
                            while (x < data.length) {
                                for (var i = 0; i < 3; i++) {
                                    delta = data[x++];
                                    cur[i] += delta;
                                }
                                var parity = (cur[0] + cur[1] + cur[2]) & 1;
                                var voxel = new THREE.Mesh(cube, new THREE.MeshColorFillMaterial(colors[parity * 5]));
                                voxel.position.x = cur[0] * 50 + 25;
                                voxel.position.y = cur[1] * 50 + 25;
                                voxel.position.z = cur[2] * 50 + 25;
                                voxel.overdraw = true;
                                scene.addObject(voxel);
                                putGrid(voxel, cur);
                            }
                        }
                        else {
                            alert("Unknown encoding type: " + version);
                        }
                    }
                }
                updateHash();

            }
            
            function hash2url(hash){
                var sep = "?";
                var url = "" + window.location;
                var i = url.indexOf('?hash=');
                if (i == -1) {
                    i = url.indexOf('&hash=');
                    if (i == -1) {
                        if (url.indexOf("?") > -1) 
                            sep = "&"
                        i = url.indexOf("/#");
                        if (i == -1) {
                            i = url.length;
                        }
                    }
                    else {
                        sep = "&";
                    }
                }
                url = url.substr(0, i) + sep + "hash=" + hash;
                return url;
            }

            function updateHash(noLink) {
                var key, keys = [];
                for (key in grid) {
                    keys.push(key);
                }
                keys.sort();
                cellCount = keys.length;
                var data = [];
                var cur = [0, 0, 0];
                for (var k in keys) {
                    key = keys[k];
                    xyz = eval("[" + key + "]");
                    for (var j=0; j<3; j++) {
                        var delta = xyz[j] - cur[j];
                        data.push(delta);
                    }
                    cur = xyz;
                }
                data = encdec_encode(data);
                data +=     (frame % 6 + 6) % 6

                if (!noLink) {                          // yuck. The part of my job I hate
                    gUpdateHash = data;
                }
                //document.getElementById('showhash').innerHTML = data;
                if (data != lasthash) {
                    if (data in hashmap) {
                        document.getElementById("duplicates").innerHTML = frame + "=" + hashmap[data] + " cycle: " + Math.abs(frame - hashmap[data]);
                    }
                }
                document.getElementById('cellcount').innerHTML = cellCount;
                hashmap[data] = frame;
                lasthash = data;
            }

            function render() {

                renderer.render( scene, camera );

            }

            function clearGrid() {
                cursor = [0, 0, 0]
                setBrushPosition(cursor);
                clearScreen();
                if (lastSelectedEl) lastSelectedEl.style.backgroundColor="#ddd";
                processSpeed = "slow";
                updateHash();
                refreshUrl(hash2url(gUpdateHash));
            }

            function reset(hash) {
                if (!hash) hash = gUpdateHash;
                cursor = gLastCursor;
                setBrushPosition(cursor);
                clearScreen();
                buildFromHash(hash);
                refreshUrl(hash2url(gUpdateHash));
            }
            
            function update(){
                if (lastSelectedEl) {
                    lastSelectedEl.style.backgroundColor="#ddd";
                }
                updateHash();
                refreshUrl(hash2url(gUpdateHash));
            }
            
            function selectHash(hash, el) {
                if (lastSelectedEl) {
                    lastSelectedEl.style.backgroundColor="#ddd";
                }
                reset(hash);
                el.style.backgroundColor="cyan";
                lastSelectedEl = el;
            }

            function clearScreen() {
                isRunning = false;
                grid = {};
                var i = 0;

                while ( i < scene.objects.length ) {

                    object = scene.objects[ i ];

                    if ( object instanceof THREE.Mesh && object !== plane && object !== brush ) {

                        scene.removeObject( object );
                        continue;
                    }

                    i ++;
                }

                frame = 0;
                hashmap = {};
                lasthash = "";
                direction = "forward";
                document.getElementById("generation").innerHTML = "";
                document.getElementById("showphase").innerHTML = "";
                document.getElementById("duplicates").innerHTML = "";
                document.getElementById("cellcount").innerHTML = "";
                setTimeout(render, 100);
            }
            
            function randomCells(){
                var val = prompt("specify width, count:", "5, 20");
                if (!val) {
                    alert ("oops! nothing");
                } 
                var i = val.indexOf(",");
                if (i < 0) {
                    alert("missing comma!");
                    return;
                }
                var width, count;
                width = parseFloat(val.substr(0,i));
                count = parseInt(val.substr(i+1));
                var axMax, axMin;
                if (width != parseInt(width)) {
                    var tot = axisMax - axisMin;
                    width = parseInt(tot * width);
                    axMax = [axisMax, axisMax, axisMax];
                    axMin = [tot - width + axisMin, axisMin, axisMin];
                }
                else {
                    width = parseInt(width);
                    axMax = parseInt(width - .5) >> 1;
                    axMin = axMax - (width - 1);
                    axMax = [axMax, axMax, axMax];
                    axMin = [axMin, axMin, axMin];
                }
                clearScreen();
                if (lastSelectedEl) lastSelectedEl.style.backgroundColor="#ddd";
                for (i = 0; i < count; i++) {
                    var phase = -1;
                    while ( (cursor in grid) || (phase != (i & 1)) ) {
                        for (var axis = 0; axis < 3; axis++) {
                            cursor[axis] = Math.floor(Math.random() * (axMax[axis] - axMin[axis] + 1) + axMin[axis]);
                        }
                        phase = (cursor[0] + cursor[1] + cursor[2]) & 1;
                    }
                    setBrushPosition(cursor);
                    var voxel = new THREE.Mesh(cube, new THREE.MeshColorFillMaterial(colors[color]));
                    putGrid(voxel, cursor);
                    setObjPosition(voxel, cursor);
                    voxel.overdraw = true;
                    scene.addObject(voxel);
                }

                updateHash();
                refreshUrl(hash2url(gUpdateHash));
            }

            // https://gist.github.com/665235

            function decode( string ) {

                var output = [];
                string.split('').forEach( function ( v ) { output.push( "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf( v ) ); } );
                return output;

            }

            function encode( array ) {

                var output = "";
                array.forEach( function ( v ) { output += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt( v ); } );
                return output;

            }

            function fastSlow() {
                if (processSpeed == "fast") {
                    processSpeed = "slow";
                }
                else {
                    processSpeed = "fast";
                }
            }

            function playStopMusic() {
                if (!document.musicPlaying) {
                    document.getElementById("music").load();            // well this fixes the chrome bug, but forces play from top
                    document.getElementById("music").play();
                    document.musicPlaying = true;
                }
                else {
                    document.getElementById("music").pause();
                    document.musicPlaying = false;
                }
            }
        </script>
        <img src="tracking.jpg"></img>
    </body>
</html>
